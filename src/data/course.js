export const course =  {
    status: "success",
    message: "Success get course!",
    data: {
        user_id: "b640e69a-1bd3-4053-bcad-71bb0342485f",
        course_id: "cmekq7o780003pk0ima09m3k7",
        created_at: "2025-08-21T01:31:54.587Z",
        updated_at: "2025-08-21T01:31:54.587Z",
        course: {
            id: "cmekq7o780003pk0ima09m3k7",
            title: "Mobile Back End Development",
            description: "This beginner-friendly course introduces the core concepts of mobile backend development. You'll learn how to design, build, and deploy server-side infrastructure that powers mobile applications. Topics covered include API design, database integration, user authentication, and cloud platform utilization. By the end, you'll have a foundational understanding of what it takes to create robust and scalable backends for your mobile apps.",
            topic_id: "cmek42hab0000lrb4ua16cz84",
            difficulty: "beginner",
            generated_by: "b640e69a-1bd3-4053-bcad-71bb0342485f",
            created_at: "2025-08-21T01:31:54.308Z",
            updated_at: "2025-08-21T01:31:54.308Z",
            chapters: [
                {
                    id: "cmekq7o790004pk0ik1vo0tao",
                    course_id: "cmekq7o780003pk0ima09m3k7",
                    order_index: 1,
                    title: "Understanding the Role of Mobile Backend",
                    description: "This chapter defines what a mobile backend is and why it's crucial for most modern applications. We will explore the common components of a backend, such as servers, databases, and APIs. You'll learn about the fundamental interactions between a mobile app and its backend services. We'll also discuss the benefits of having a robust backend, including data persistence, user management, and complex business logic. Understanding these foundational elements is key to building effective and scalable mobile solutions. This initial overview sets the stage for more in-depth topics throughout the course.",
                    content: "Chapter 1: Understanding the Role of Mobile Backend 1. What is a Mobile Backend?\n\nIn the world of mobile application development, a mobile backend refers to the server-side infrastructure that provides the necessary functionality, data storage, and business logic for a mobile application to operate effectively. While the mobile application (the frontend) runs on the user's device (smartphone, tablet, etc.), the backend resides on remote servers, accessible over the internet.\n\nThink of it like this: your mobile app is the car, and the backend is the entire network of roads, gas stations, traffic control, and navigation systems that allow the car to reach its destination and perform its functions. The app handles the user interface and basic on-device logic, but for tasks like storing user data, fetching real-time information, processing complex requests, or authenticating users, it relies on the backend.\n\nCommon components of a mobile backend include:\n* **Servers:** These are the computational engines that run the backend code.\n* **Databases:** Systems for storing, organizing, and retrieving data.\n* **APIs (Application Programming Interfaces):** A set of rules that defines how the mobile app communicates with the backend.\n* **Authentication and Authorization Services:** For managing user identities and permissions.\n* **File Storage:** For managing user-uploaded content like images or videos.\n* **Push Notification Services:** To send real-time alerts and updates to users.\n\n### 2. Why is a Mobile Backend Crucial?\n\nWhile simple apps might function entirely on a device, most modern mobile applications require a backend for various critical reasons:\n\n* **Data Persistence and Storage:** Mobile devices have limited storage and their data can be lost if the app is uninstalled or the device is damaged. A backend provides a centralized and persistent place to store user data, application content, and configuration settings, ensuring data availability across sessions and devices.\n* **User Management and Authentication:** To build apps that require user accounts (e.g., social media, e-commerce, banking), a backend is essential for user registration, login, profile management, and secure authentication (e.g., verifying passwords, handling password resets).\n* **Complex Business Logic:** Many applications require sophisticated computations, data processing, or integration with external services. Offloading this heavy lifting to a powerful backend server prevents the mobile app from becoming slow or draining device battery. This also allows for easier updates to logic without requiring app store updates.\n* **Scalability:** A robust backend can be designed to handle a growing number of users and requests simultaneously. As your app gains popularity, the backend can be scaled to accommodate the increased load without performance degradation.\n* **Cross-Platform Consistency:** If your app is available on multiple platforms (iOS, Android, web), a single backend ensures that all versions of the app access the same data and provide a consistent user experience.\n* **Security:** Centralizing data and logic on a backend allows for better security controls, encryption, and protection against unauthorized access. Sensitive information can be stored securely away from the potentially vulnerable client device.\n* **Real-time Features and Push Notifications:** Features like chat, live updates, or sending push notifications to users require a backend service that can manage connections and deliver messages efficiently.\n\n### 3. Core Components and Concepts\n\nUnderstanding the foundational elements that make up a mobile backend is crucial. While specific technologies may vary, the logical components remain similar:\n\n#### 3.1 Servers and Runtime Environments\nThis is where your backend code lives and executes. Popular choices include:\n* **Node.js (JavaScript):** Popular for its non-blocking I/O and suitability for real-time applications.\n* **Python (Django, Flask):** Known for its simplicity, readability, and vast libraries, great for data processing and AI.\n* **Java (Spring Boot):** Enterprise-grade, highly scalable, and performant.\n* **Go (Golang):** Excellent for high-performance network services and concurrency.\n* **Ruby (Ruby on Rails):** Known for rapid development and convention over configuration.\n\n#### 3.2 Databases\nDatabases store your application's data. They are broadly categorized into:\n* **Relational Databases (SQL):** Store data in structured tables with predefined schemas. Examples: `PostgreSQL`, `MySQL`, `MariaDB`, `SQL Server`. Ideal for complex queries and ensuring data integrity.\n* **Non-Relational Databases (NoSQL):** Offer more flexible schemas and are designed for specific data models. Examples:\n    * **Document Databases:** `MongoDB`, `Couchbase` (for JSON-like documents).\n    * **Key-Value Stores:** `Redis`, `DynamoDB` (for simple key-value pairs).\n    * **Column-Family Stores:** `Cassandra` (for large datasets).\n    * **Graph Databases:** `Neo4j` (for highly connected data).\n\n#### 3.3 APIs (Application Programming Interfaces)\nAPIs define the communication contract between your mobile app and the backend. They specify how the app can request information or send data to the server.\n* **RESTful APIs:** The most common type, using standard HTTP methods (`GET` to retrieve, `POST` to create, `PUT` to update, `DELETE` to remove) and operating on resources identified by URLs. Data is typically exchanged in JSON or XML format.\n* **GraphQL:** A query language for APIs that allows clients to request exactly the data they need, reducing over-fetching or under-fetching.\n\n#### 3.4 Authentication and Authorization\nThese services manage who can access your backend and what they are allowed to do.\n* **Authentication:** Verifies the identity of a user (e.g., username/password, social login, multi-factor authentication).\n* **Authorization:** Determines what an authenticated user is permitted to do (e.g., an admin can delete users, a regular user cannot).\n* **Token-based Authentication:** Commonly uses JSON Web Tokens (`JWT`) where the server issues a token upon successful login, and the app includes this token in subsequent requests to prove its identity.\n\n#### 3.5 Cloud Platforms and Backend-as-a-Service (BaaS)\nCloud providers offer managed services that simplify backend development:\n* **Infrastructure as a Service (IaaS):** `AWS EC2`, `Google Compute Engine`, `Azure VMs` (you manage servers, OS, etc.).\n* **Platform as a Service (PaaS):** `AWS Elastic Beanstalk`, `Google App Engine`, `Heroku` (you deploy code, platform manages infrastructure).\n* **Function as a Service (FaaS) / Serverless:** `AWS Lambda`, `Google Cloud Functions`, `Azure Functions` (you deploy small functions, no servers to manage).\n* **Backend-as-a-Service (BaaS):** `Firebase`, `AWS Amplify`, `Supabase` (provides pre-built backend functionalities like authentication, databases, storage, real-time sync, pushing notifications with minimal server-side coding).\n\n### 4. How Mobile Apps Interact with Backends\n\nThe interaction between a mobile app and its backend typically follows a request-response cycle over HTTP (Hypertext Transfer Protocol).\n\n1.  **Request from Mobile App:** The user performs an action in the app (e.g., taps a \"Login\" button, pulls to refresh a feed, submits a form). The app constructs an HTTP request (e.g., `POST` request to `/login`, `GET` request to `/products`). This request includes:\n    * **HTTP Method:** (e.g., `GET`, `POST`, `PUT`, `DELETE`)\n    * **URL/Endpoint:** The specific address on the backend (e.g., `https://api.myapp.com/v1/users/profile`)\n    * **Headers:** Metadata like `Content-Type`, `Authorization` tokens, `Accept`.\n    * **Body (for POST/PUT):** The data being sent (e.g., username and password for login, new product details).\n\n2.  **Backend Processing:** The backend server receives the request.\n    * It identifies the API endpoint being accessed.\n    * It may check for authentication and authorization.\n    * It performs necessary business logic (e.g., validates data, performs calculations).\n    * It interacts with the database to store or retrieve data.\n    * It compiles a response.\n\n3.  **Response to Mobile App:** The backend sends an HTTP response back to the mobile app. This response includes:\n    * **HTTP Status Code:** Indicates the outcome (e.g., `200 OK` for success, `404 Not Found`, `500 Internal Server Error`, `401 Unauthorized`).\n    * **Headers:** Metadata like `Content-Type`.\n    * **Body:** The data requested by the app (e.g., user profile data in JSON), or a success/error message.\n\n4.  **Mobile App Handles Response:** The mobile app receives the response and updates its UI accordingly (e.g., displays user's feed, shows an error message, navigates to a new screen).\n\n### 5. Simple Interaction Example\n\nLet's illustrate a common interaction: a mobile app fetching a user's profile data.\n\n**Scenario:** A user opens their profile screen in a mobile application. The app needs to display their name, email, and profile picture URL, which are stored on the backend.\n\n**Conceptual Flow:**\n\n1.  **Mobile App (Frontend) Action:** The app detects the user navigating to the profile screen.\n2.  **App Constructs Request:** The app prepares an HTTP `GET` request to the backend's user profile API endpoint. It includes an `Authorization` header with the user's valid access token (obtained during login).\n\n    ```\n    GET /users/me\n    Host: api.myapp.com\n    Authorization: Bearer <user_access_token>\n    Accept: application/json\n    ```\n\n3.  **Backend (Server) Receives Request:**\n    * The server receives the `GET /users/me` request.\n    * It extracts the `Authorization` header and validates the `<user_access_token>`.\n    * If the token is valid, it identifies the user associated with that token.\n    * It then queries its database to retrieve the profile information for that user.\n\n    ```python\n    # Conceptual Python Flask/Node.js Express snippet on the backend\n    @app.route('/users/me', methods=['GET'])\n    def get_my_profile():\n        # 1. Get token from Authorization header\n        auth_header = request.headers.get('Authorization')\n        token = auth_header.split(' ')[1] if auth_header else None\n\n        # 2. Validate token and get user_id\n        user_id = validate_token(token) \n        if not user_id:\n            return jsonify({\"message\": \"Unauthorized\"}), 401\n\n        # 3. Query database for user profile\n        user_profile = db.get_user_by_id(user_id)\n        if not user_profile:\n            return jsonify({\"message\": \"User not found\"}), 404\n\n        # 4. Return profile data\n        return jsonify({\n            \"id\": user_profile.id,\n            \"name\": user_profile.name,\n            \"email\": user_profile.email,\n            \"profile_pic_url\": user_profile.profile_pic_url\n        }), 200\n    ```\n\n4.  **Backend Sends Response:** The backend constructs an HTTP response with a `200 OK` status code and the user's profile data in JSON format.\n\n    ```\n    HTTP/1.1 200 OK\n    Content-Type: application/json\n\n    {\n        \"id\": \"user123\",\n        \"name\": \"Jane Doe\",\n        \"email\": \"jane.doe@example.com\",\n        \"profile_pic_url\": \"[https://cdn.myapp.com/profiles/user123.jpg](https://cdn.myapp.com/profiles/user123.jpg)\"\n    }\n    ```\n\n5.  **Mobile App (Frontend) Handles Response:**\n    * The app receives the `200 OK` response.\n    * It parses the JSON body to extract the `name`, `email`, and `profile_pic_url`.\n    * It updates the UI elements on the profile screen to display this information.\n    * If a `401 Unauthorized` or `404 Not Found` (or any other error code) was received, the app would show an appropriate error message to the user.\n\nThis simple example demonstrates the fundamental client-server interaction that forms the backbone of almost all mobile applications requiring external data or services.\n\n### 6. Summary: Key Takeaways\n\nThis chapter introduced the fundamental concept of a mobile backend and its indispensable role in modern mobile application development.\n\nHere are the key takeaways:\n\n* A **mobile backend** is the server-side infrastructure that supports mobile apps, handling data storage, business logic, and communication.\n* It is crucial for **data persistence**, **user management**, executing **complex business logic**, ensuring **scalability**, providing **cross-platform consistency**, enhancing **security**, and enabling **real-time features** like push notifications.\n* Core components include **servers** (runtime environments like Node.js, Python), **databases** (SQL and NoSQL), **APIs** (REST, GraphQL) for communication, and **authentication/authorization services**.\n* **Cloud platforms** and **BaaS** solutions significantly simplify backend development and deployment.\n* Mobile apps interact with backends via a **request-response cycle** over HTTP, utilizing API endpoints to exchange data typically in JSON format.\n\nUnderstanding these foundational elements is the first step towards designing and building robust, scalable, and secure backends for your mobile applications. The subsequent chapters will delve deeper into each of these components and practical implementation strategies.",
                    video_url: "https://www.youtube.com/watch?v=XBu54nfzxAQ",
                    video_url_embed: "https://www.youtube.com/embed/XBu54nfzxAQ",
                    is_active: true,
                    is_study_case: false,
                    created_at: "2025-08-21T01:31:54.308Z",
                    updated_at: "2025-08-21T01:32:19.117Z",
                    progress: [
                        {
                            is_done: true
                        }
                    ]
                },
                {
                    id: "cmekq7o790005pk0icnvvn5aa",
                    course_id: "cmekq7o780003pk0ima09m3k7",
                    order_index: 2,
                    title: "Designing RESTful APIs for Mobile Apps",
                    description: "This chapter dives into the principles of designing effective APIs for mobile applications. We will focus specifically on RESTful API design, a widely adopted standard for web services. You'll learn about HTTP methods, status codes, and proper resource naming conventions. Understanding how to structure your API endpoints is crucial for creating maintainable and intuitive interfaces. We'll also discuss versioning strategies and common pitfalls to avoid when designing APIs. This knowledge will enable you to build robust and developer-friendly interfaces for your mobile clients.",
                    content: "## Chapter 2: Designing RESTful APIs for Mobile Apps\n\n### 1. What is RESTful API Design?\n\nREST (Representational State Transfer) is an architectural style that defines a set of constraints for creating web services. A RESTful API adheres to these constraints, providing a standardized and stateless way for different systems, such as a mobile application and a backend server, to communicate. It primarily leverages the existing capabilities of the HTTP protocol.\n\nKey principles of REST include:\n* **Client-Server:** Separation of concerns between the client (mobile app) and the server (backend).\n* **Stateless:** Each request from client to server must contain all the information necessary to understand the request. The server should not store any client context between requests.\n* **Cacheable:** Responses must explicitly or implicitly define themselves as cacheable to prevent clients from requesting the same data multiple times.\n* **Uniform Interface:** This is the most crucial constraint, simplifying the overall system architecture by providing a uniform way to interact with resources. It includes:\n    * **Resource Identification in Requests:** Individual resources are identified in requests, e.g., using URIs.\n    * **Resource Manipulation Through Representations:** Clients manipulate resources using representations (e.g., JSON, XML) of those resources.\n    * **Self-Descriptive Messages:** Each message contains enough information to describe how to process the message.\n    * **Hypermedia as the Engine of Application State (HATEOAS):** Resources should provide links to other related resources, guiding the client through the API.\n\nFor mobile backend development, RESTful APIs serve as the primary communication bridge, allowing mobile apps to fetch, send, update, and delete data on the server efficiently and consistently.\n\n### 2. Why is Effective RESTful API Design Crucial for Mobile Apps?\n\nDesigning robust and efficient RESTful APIs is paramount for mobile applications due to several unique challenges and requirements of the mobile environment:\n\n* **Performance and Responsiveness:** Mobile users expect fast, fluid experiences. Well-designed APIs minimize payload sizes, reduce latency, and optimize data transfer, leading to faster loading times and a more responsive app.\n* **Battery Life Conservation:** Efficient APIs that transfer less data and require fewer requests translate to less network activity and CPU usage on the mobile device, significantly extending battery life.\n* **Network Variability:** Mobile devices often operate on unreliable or slow networks (e.g., cellular data). APIs designed with efficiency and resilience in mind perform better under these conditions.\n* **Developer Experience:** A clear, consistent, and well-documented API makes it significantly easier for mobile developers to integrate with the backend, reducing development time and the likelihood of errors.\n* **Scalability and Maintainability:** Stateless APIs are inherently easier to scale horizontally. A consistent design also makes the backend easier to maintain and evolve as new features are added or requirements change.\n* **Security:** Proper API design incorporates robust authentication and authorization mechanisms, ensuring that only legitimate users can access and manipulate data.\n* **Future-proofing with Versioning:** Mobile apps have longer update cycles. API versioning allows you to evolve your backend without breaking older versions of your mobile app, providing a smoother transition for users.\n\n### 3. Tools and Concepts for RESTful API Design\n\nWhile specific tools or libraries are tied to the backend language/framework (e.g., Express.js for Node.js, Flask/Django for Python), the following concepts are universal to RESTful API design:\n\n* **HTTP Methods (Verbs):** These define the action to be performed on a resource.\n    * `GET`: Retrieve a resource or collection. (Idempotent, safe)\n    * `POST`: Create a new resource. (Not idempotent, not safe)\n    * `PUT`: Completely update an existing resource or create if it doesn't exist. (Idempotent)\n    * `PATCH`: Partially update an existing resource. (Not idempotent)\n    * `DELETE`: Remove a resource. (Idempotent)\n* **HTTP Status Codes:** Standardized codes indicating the outcome of an API request.\n    * `2xx` (Success): `200 OK`, `201 Created`, `204 No Content`.\n    * `4xx` (Client Error): `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `409 Conflict`, `429 Too Many Requests`.\n    * `5xx` (Server Error): `500 Internal Server Error`, `503 Service Unavailable`.\n* **Resource Naming Conventions:** Use clear, consistent, and plural nouns for collections (e.g., `/users`, `/products`) and singular nouns for specific instances (e.g., `/users/123`, `/products/abc`). Avoid verbs in URIs.\n* **Request/Response Formats:** JSON (JavaScript Object Notation) is the de facto standard for data interchange due to its lightweight nature and ease of parsing for mobile clients.\n* **API Versioning:** Strategies to manage changes to your API over time. Common methods include:\n    * **URI Versioning:** `https://api.example.com/v1/users`\n    * **Header Versioning:** Using a custom `Accept` header like `Accept: application/vnd.example.v1+json`\n    * **Query Parameter Versioning:** `https://api.example.com/users?version=1` (less common for major versions).\n* **Pagination, Filtering, Sorting:** For large datasets, use query parameters for pagination (`?page=1&limit=20`), filtering (`?status=active`), and sorting (`?sort_by=name&order=asc`).\n* **Error Handling:** Provide consistent and informative error responses (e.g., JSON object with `code`, `message`, `details`).\n* **Authentication and Authorization:** Secure your API using tokens (e.g., JWT) to verify user identity and permissions.\n\n### 4. Key Steps and Concepts in Designing RESTful APIs\n\nDesigning a RESTful API involves a structured approach to ensure consistency, usability, and scalability.\n\n1.  **Identify Resources:**\n    * Begin by identifying the core \"things\" or entities your application deals with. These will become your API resources. For a social media app, resources might be `users`, `posts`, `comments`, `likes`.\n    * Represent resources as nouns, typically plural.\n2.  **Define Endpoints and HTTP Methods:**\n    * Map the resources to URIs and assign appropriate HTTP methods for different operations.\n    * **Collection URI:** `/resources` (e.g., `/users`, `/products`)\n        * `GET /resources`: Retrieve a list of resources.\n        * `POST /resources`: Create a new resource.\n    * **Instance URI:** `/resources/{id}` (e.g., `/users/123`, `/products/A4B5C6`)\n        * `GET /resources/{id}`: Retrieve a specific resource.\n        * `PUT /resources/{id}`: Fully update a specific resource.\n        * `PATCH /resources/{id}`: Partially update a specific resource.\n        * `DELETE /resources/{id}`: Delete a specific resource.\n3.  **Design Request and Response Payloads:**\n    * Determine the structure of the data sent by the client (request body for `POST`, `PUT`, `PATCH`) and the data returned by the server (response body for `GET`, `POST`, `PUT`, `PATCH`).\n    * Use JSON as the data format. Define clear fields, data types, and required vs. optional properties.\n4.  **Implement HTTP Status Codes:**\n    * Return the correct HTTP status code to indicate the success or failure of an operation and provide more context about the outcome.\n    * Example: `200 OK` for successful `GET`/`PUT`/`PATCH`/`DELETE`, `201 Created` for successful `POST`, `404 Not Found` if a resource doesn't exist.\n5.  **Handle Authentication and Authorization:**\n    * Decide how clients will authenticate (e.g., API keys, OAuth, JWT tokens).\n    * Implement authorization checks to ensure users only access resources they are permitted to. (Detailed in a later chapter).\n6.  **Plan for API Versioning:**\n    * Anticipate future changes. Decide on a versioning strategy (e.g., `/v1/`, `/v2/`) early on to prevent breaking existing mobile clients when the API evolves.\n7.  **Standardize Error Handling:**\n    * Define a consistent format for error responses. This typically includes an error code, a user-friendly message, and sometimes specific details about the error.\n8.  **Document Your API:**\n    * Comprehensive API documentation is vital for mobile developers. Tools like OpenAPI (Swagger) can help define and generate interactive documentation.\n\n### 5. Real Example: A Simple Task Management API\n\nLet's design a basic RESTful API for a mobile task management application.\n\n**Resource:** `tasks`\n\n**API Versioning Strategy:** URI versioning (`/api/v1/`)\n\n**Endpoints and Operations:**\n\n1.  **Get All Tasks**\n    * **URI:** `GET /api/v1/tasks`\n    * **Purpose:** Retrieve a list of all tasks.\n    * **Query Parameters (Optional):**\n        * `status`: Filter by task status (e.g., `completed`, `pending`).\n        * `limit`, `offset`: For pagination.\n    * **Response:**\n        * `200 OK`\n        ```json\n        [\n          {\n            \"id\": \"task-abc-123\",\n            \"title\": \"Buy groceries\",\n            \"description\": \"Milk, eggs, bread\",\n            \"status\": \"pending\",\n            \"dueDate\": \"2024-03-15T10:00:00Z\"\n          },\n          {\n            \"id\": \"task-def-456\",\n            \"title\": \"Call mom\",\n            \"description\": \"Check in and chat\",\n            \"status\": \"completed\",\n            \"dueDate\": null\n          }\n        ]\n        ```\n\n2.  **Create a New Task**\n    * **URI:** `POST /api/v1/tasks`\n    * **Purpose:** Add a new task to the system.\n    * **Request Body:**\n        ```json\n        {\n          \"title\": \"Learn API Design\",\n          \"description\": \"Read Chapter 2 for mobile backend development\",\n          \"dueDate\": \"2024-04-01T17:00:00Z\"\n        }\n        ```\n    * **Response:**\n        * `201 Created` (with `Location` header pointing to the new resource)\n        ```json\n        {\n          \"id\": \"task-ghi-789\",\n          \"title\": \"Learn API Design\",\n          \"description\": \"Read Chapter 2 for mobile backend development\",\n          \"status\": \"pending\",\n          \"dueDate\": \"2024-04-01T17:00:00Z\"\n        }\n        ```\n        * `400 Bad Request` if `title` is missing or invalid.\n\n3.  **Get a Single Task**\n    * **URI:** `GET /api/v1/tasks/{taskId}` (e.g., `/api/v1/tasks/task-abc-123`)\n    * **Purpose:** Retrieve details of a specific task.\n    * **Response:**\n        * `200 OK`\n        ```json\n        {\n          \"id\": \"task-abc-123\",\n          \"title\": \"Buy groceries\",\n          \"description\": \"Milk, eggs, bread\",\n          \"status\": \"pending\",\n          \"dueDate\": \"2024-03-15T10:00:00Z\"\n        }\n        ```\n        * `404 Not Found` if `taskId` does not exist.\n\n4.  **Update an Existing Task (Full Update)**\n    * **URI:** `PUT /api/v1/tasks/{taskId}`\n    * **Purpose:** Replace all data for an existing task with the provided data.\n    * **Request Body:**\n        ```json\n        {\n          \"id\": \"task-abc-123\",\n          \"title\": \"Buy groceries and medicine\",\n          \"description\": \"Milk, eggs, bread, and paracetamol\",\n          \"status\": \"completed\",\n          \"dueDate\": \"2024-03-15T10:00:00Z\"\n        }\n        ```\n    * **Response:**\n        * `200 OK`\n        ```json\n        {\n          \"id\": \"task-abc-123\",\n          \"title\": \"Buy groceries and medicine\",\n          \"description\": \"Milk, eggs, bread, and paracetamol\",\n          \"status\": \"completed\",\n          \"dueDate\": \"2024-03-15T10:00:00Z\"\n        }\n        ```\n        * `404 Not Found` if `taskId` does not exist.\n\n5.  **Partially Update an Existing Task**\n    * **URI:** `PATCH /api/v1/tasks/{taskId}`\n    * **Purpose:** Update only specific fields of an existing task.\n    * **Request Body:**\n        ```json\n        {\n          \"status\": \"completed\"\n        }\n        ```\n    * **Response:**\n        * `200 OK`\n        ```json\n        {\n          \"id\": \"task-abc-123\",\n          \"title\": \"Buy groceries\",\n          \"description\": \"Milk, eggs, bread\",\n          \"status\": \"completed\",\n          \"dueDate\": \"2024-03-15T10:00:00Z\"\n        }\n        ```\n        * `404 Not Found` if `taskId` does not exist.\n\n6.  **Delete a Task**\n    * **URI:** `DELETE /api/v1/tasks/{taskId}`\n    * **Purpose:** Remove a task from the system.\n    * **Response:**\n        * `204 No Content` (success, no content to return).\n        * `404 Not Found` if `taskId` does not exist.\n\n### 6. Summary\n\nDesigning effective RESTful APIs is a fundamental skill for mobile backend development. This chapter emphasized that REST is not just about using HTTP, but about adhering to a set of architectural constraints that promote scalability, maintainability, and usability.\n\nKey takeaways include:\n* **Resources are Nouns:** Your API should be centered around resources (e.g., `users`, `products`), not actions.\n* **HTTP Methods are Verbs:** Leverage `GET`, `POST`, `PUT`, `PATCH`, `DELETE` to define actions on these resources.\n* **Status Codes Communicate:** Use appropriate HTTP status codes to clearly indicate the outcome of API requests to the client.\n* **JSON is King:** Prefer JSON for data interchange due to its widespread support and efficiency.\n* **Consistency is Crucial:** Uniform naming conventions, error formats, and versioning strategies improve developer experience and reduce integration effort for mobile clients.\n* **Mobile-First Considerations:** Always think about network conditions, battery life, and payload size when designing APIs for mobile consumption.\n\nMastering these principles will enable you to build robust, scalable, and developer-friendly backends that effectively power your mobile applications.",
                    video_url: "https://www.youtube.com/watch?v=B3l_qaKOlL0",
                    video_url_embed: "https://www.youtube.com/embed/B3l_qaKOlL0",
                    is_active: true,
                    is_study_case: false,
                    created_at: "2025-08-21T01:31:54.308Z",
                    updated_at: "2025-08-21T01:32:22.470Z",
                    progress: [
                        {
                            is_done: false
                        }
                    ]
                },
                {
                    id: "cmekq7o790006pk0ic40jezo7",
                    course_id: "cmekq7o780003pk0ima09m3k7",
                    order_index: 3,
                    title: "Selecting and Integrating Databases",
                    description: "This chapter explores various database options suitable for mobile backend development. We will differentiate between relational databases like PostgreSQL and NoSQL databases such as MongoDB or Firebase Realtime Database. You'll learn about the strengths and weaknesses of each database type in the context of mobile application needs. We'll also cover basic data modeling concepts and how to choose the right database based on your app's specific requirements. Understanding database integration is fundamental for storing and retrieving application data efficiently. This chapter provides the knowledge to make informed decisions about your backend's data layer.",
                    content: "## Chapter 3: Selecting and Integrating Databases\n\n### 1. What are Databases in Mobile Backend Development?\n\nIn mobile backend development, databases serve as the persistent storage layer for all your application's data. Whether it's user profiles, product catalogs, chat messages, or game scores, this information needs to be stored reliably and retrieved efficiently. A database management system (DBMS) allows your backend server to interact with this stored data, performing operations like creating new records, reading existing data, updating information, and deleting obsolete entries. For mobile applications, the database must be capable of handling varying data structures, supporting concurrent access from many users, and scaling to accommodate growth in both data volume and user base.\n\n### 2. Why is Database Selection Crucial for Mobile Applications?\n\nChoosing the right database is one of the most critical decisions in mobile backend development, directly impacting your application's performance, scalability, development speed, and overall user experience.\n\n* **Performance:** The speed at which your app can store and retrieve data directly affects its responsiveness. A poorly chosen or optimized database can lead to slow loading times, frustrated users, and ultimately, app abandonment.\n* **Scalability:** Mobile apps can experience rapid growth. Your database must be able to scale efficiently (vertically or horizontally) to handle an increasing number of users and a growing volume of data without significant architectural changes.\n* **Data Consistency & Integrity:** Ensuring that data is accurate and reliable is paramount. Different databases offer varying levels of consistency guarantees, which are vital for critical operations like transactions or user authentication.\n* **Development Speed:** The ease of integrating with a database and its flexibility in handling changing data requirements can significantly impact your development timeline. NoSQL databases, for instance, often provide more flexibility with schema evolution, which can be beneficial in agile development.\n* **Cost:** Database solutions vary in their operational costs, including hosting, maintenance, and potential licensing fees. Cloud-based database services often offer pay-as-you-go models, but it's important to understand the pricing structure for anticipated usage.\n\n### 3. Key Database Tools and Libraries\n\nThe world of databases offers a wide array of choices, broadly categorized into Relational (SQL) and Non-Relational (NoSQL) databases. Your backend language/framework will typically use specific libraries or ORMs/ODMs to interact with these databases.\n\n#### Relational Databases (SQL)\n\nThese databases store data in structured tables with predefined schemas. They enforce strong consistency and are excellent for complex queries involving relationships between data.\n\n* **PostgreSQL:** A powerful, open-source object-relational database system known for its robustness, advanced features, and extensibility.\n    * **Libraries/ORMs (Node.js):** `pg` (Node.js driver), `Sequelize` (ORM), `TypeORM` (ORM).\n* **MySQL:** Another popular open-source relational database, widely used for web applications.\n    * **Libraries/ORMs (Node.js):** `mysql2` (Node.js driver), `Sequelize`, `TypeORM`.\n* **SQLite:** A lightweight, embedded relational database often used for local storage on mobile devices, but less common for central backend servers.\n\n#### Non-Relational Databases (NoSQL)\n\nNoSQL databases offer more flexible data models and are often optimized for specific use cases like high scalability, real-time data, or unstructured data.\n\n* **Document Databases:** Store data in flexible, semi-structured documents (e.g., JSON or BSON). Ideal for content management, user profiles, and product catalogs.\n    * **MongoDB:** A leading document database, popular for its scalability and flexibility.\n        * **Libraries/ODMs (Node.js):** `mongodb` (Node.js driver), `Mongoose` (ODM).\n    * **Google Cloud Firestore:** A flexible, scalable NoSQL document database for mobile, web, and server development from Google. Offers real-time synchronization.\n    * **Firebase Realtime Database:** Google's original real-time NoSQL cloud database. Synchronizes data instantly across connected clients.\n* **Key-Value Stores:** Store data as simple key-value pairs. Excellent for caching, session management, and simple data retrieval.\n    * **Redis:** An in-memory data structure store, used as a database, cache, and message broker.\n        * **Libraries (Node.js):** `ioredis`, `node-redis`.\n    * **Amazon DynamoDB:** A fully managed, serverless key-value and document database service from AWS.\n* **Column-Family Stores:** Store data in columns grouped into families. Suitable for large datasets and analytical workloads.\n    * **Apache Cassandra:** Highly scalable and distributed.\n* **Graph Databases:** Optimized for storing and traversing relationships between data entities.\n    * **Neo4j:** A popular graph database.\n\n### 4. Database Selection and Integration Concepts\n\n#### 4.1. Relational vs. NoSQL: Key Differences\n\n| Feature           | Relational Databases (SQL)                               | NoSQL Databases                                    |\n| :---------------- | :------------------------------------------------------- | :------------------------------------------------- |\n| **Data Model** | Structured tables, rows, columns; predefined schema.     | Flexible, dynamic schema; document, key-value, etc. |\n| **Schema** | Rigid, schema-on-write. Changes require migrations.      | Flexible, schema-on-read. Easier for evolving data. |\n| **Scalability** | Primarily vertical (scaling up). Horizontal (sharding) is complex. | Primarily horizontal (scaling out).                |\n| **ACID** | Strong ACID (Atomicity, Consistency, Isolation, Durability) properties. | Often BASE (Basically Available, Soft state, Eventually consistent). |\n| **Use Cases** | Complex transactions, financial systems, strong data integrity, well-defined relationships. | Big data, real-time apps, flexible data, high throughput, caching. |\n| **Examples** | PostgreSQL, MySQL, SQL Server                            | MongoDB, Firebase, Redis, Cassandra, DynamoDB      |\n\n#### 4.2. Basic Data Modeling\n\n* **Relational Data Modeling:** Involves designing tables, defining columns, specifying primary and foreign keys, and establishing relationships (one-to-one, one-to-many, many-to-many). Normalization is a key concept to reduce data redundancy.\n    * **Example:** A `Users` table with `id`, `name`, `email` and a `Products` table with `id`, `name`, `price`, `description`. An `Orders` table would link `Users` and `Products`.\n* **NoSQL Data Modeling:** Often involves denormalization, where data is duplicated across documents to optimize for read performance, as joins are typically not supported or are less efficient. Data is often modeled to match how it will be queried.\n    * **Example (MongoDB):** Instead of separate tables, a `User` document might embed a list of `address` objects, and a `Product` document might include `reviews` directly within it, rather than linking to separate `Reviews` collection.\n\n#### 4.3. Factors for Database Selection\n\nWhen choosing a database for your mobile backend, consider these factors:\n\n1.  **Data Structure and Relationships:**\n    * Is your data highly structured with complex relationships? SQL might be better.\n    * Is your data semi-structured, evolving, or highly variable? NoSQL (document) might be better.\n2.  **Scalability Needs:**\n    * Do you anticipate massive scale and high read/write throughput? NoSQL is often designed for horizontal scaling.\n3.  **Consistency Requirements:**\n    * Is strong consistency (e.g., for financial transactions) absolutely critical? SQL databases provide strong ACID guarantees.\n    * Can your application tolerate eventual consistency (e.g., social media feeds)? NoSQL can offer better availability and partition tolerance.\n4.  **Performance Goals:**\n    * Are complex analytical queries common? SQL can be powerful.\n    * Are fast, simple key-value lookups or real-time data updates crucial? NoSQL (Key-Value, Document) can excel.\n5.  **Development Team Expertise:**\n    * What databases are your developers familiar with? Leverage existing knowledge.\n6.  **Cloud Provider Ecosystem:**\n    * If you're already on AWS, GCP, or Azure, leveraging their native database services (DynamoDB, Firestore, Azure Cosmos DB) can simplify integration and management.\n7.  **Cost:**\n    * Consider operational costs, managed services vs. self-hosting, and potential licensing.\n\n#### 4.4. Database Integration Concepts\n\nIntegration typically involves:\n\n1.  **Connecting to the Database:** Using a driver or SDK provided by the database vendor or a community.\n2.  **Defining Data Models (Schema/Schema-less):** Using ORMs (for SQL) or ODMs (for NoSQL) to map database structures to application objects.\n3.  **Performing CRUD Operations:** Writing code to Create, Read, Update, and Delete data.\n4.  **Error Handling and Transactions:** Implementing robust error handling and, for SQL, managing transactions to ensure data integrity.\n5.  **Connection Pooling:** Managing a pool of database connections to efficiently handle multiple requests without opening and closing connections repeatedly.\n\n### 5. Real Example: Integrating MongoDB with Node.js (Mongoose)\n\nLet's illustrate with a common mobile backend stack: Node.js and MongoDB using Mongoose, an ODM (Object Data Modeling) library. We'll create a simple API for managing `Product` data.\n\n**Scenario:** A mobile e-commerce app needs to fetch and manage product details.\n\n**Prerequisites:**\n* Node.js installed\n* MongoDB instance (local or cloud like MongoDB Atlas)\n\n**Steps:**\n\n1.  **Initialize Project and Install Dependencies:**\n    ```bash\n    mkdir product-backend\n    cd product-backend\n    npm init -y\n    npm install express mongoose dotenv\n    ```\n\n2.  **Create `.env` file for database URI:**\n    ```dotenv\n    # .env\n    MONGO_URI=\"mongodb://localhost:27017/mobile_ecommerce\"\n    PORT=3000\n    ```\n    *Replace `mongodb://localhost:27017/mobile_ecommerce` with your MongoDB Atlas connection string if using cloud.*\n\n3.  **Create `db.js` for Database Connection:**\n    ```javascript\n    // db.js\n    const mongoose = require('mongoose');\n    require('dotenv').config(); // Load environment variables\n\n    const connectDB = async () => {\n        try {\n            await mongoose.connect(process.env.MONGO_URI, {\n                useNewUrlParser: true,\n                useUnifiedTopology: true,\n            });\n            console.log('MongoDB connected successfully!');\n        } catch (err) {\n            console.error('MongoDB connection error:', err.message);\n            process.exit(1); // Exit process with failure\n        }\n    };\n\n    module.exports = connectDB;\n    ```\n\n4.  **Define Product Schema and Model (`models/Product.js`):**\n    ```javascript\n    // models/Product.js\n    const mongoose = require('mongoose');\n\n    const productSchema = new mongoose.Schema({\n        name: {\n            type: String,\n            required: true,\n            trim: true\n        },\n        description: {\n            type: String,\n            required: true\n        },\n        price: {\n            type: Number,\n            required: true,\n            min: 0\n        },\n        category: {\n            type: String,\n            trim: true\n        },\n        stock: {\n            type: Number,\n            required: true,\n            min: 0,\n            default: 0\n        },\n        imageUrl: {\n            type: String,\n            default: 'no-image.jpg'\n        },\n        createdAt: {\n            type: Date,\n            default: Date.now\n        }\n    });\n\n    const Product = mongoose.model('Product', productSchema);\n\n    module.exports = Product;\n    ```\n\n5.  **Create Express App and Product Routes (`server.js`):**\n    ```javascript\n    // server.js\n    const express = require('express');\n    const connectDB = require('./db');\n    const Product = require('./models/Product');\n    require('dotenv').config();\n\n    const app = express();\n    connectDB(); // Connect to database\n\n    app.use(express.json()); // Middleware to parse JSON request bodies\n\n    // --- Product API Routes ---\n\n    // 1. Create a new product (POST /api/products)\n    app.post('/api/products', async (req, res) => {\n        try {\n            const newProduct = new Product(req.body);\n            const product = await newProduct.save();\n            res.status(201).json(product); // 201 Created\n        } catch (err) {\n            res.status(400).json({ message: err.message }); // 400 Bad Request\n        }\n    });\n\n    // 2. Get all products (GET /api/products)\n    app.get('/api/products', async (req, res) => {\n        try {\n            const products = await Product.find();\n            res.json(products);\n        } catch (err) {\n            res.status(500).json({ message: err.message }); // 500 Server Error\n        }\n    });\n\n    // 3. Get a single product by ID (GET /api/products/:id)\n    app.get('/api/products/:id', async (req, res) => {\n        try {\n            const product = await Product.findById(req.params.id);\n            if (!product) return res.status(404).json({ message: 'Product not found' }); // 404 Not Found\n            res.json(product);\n        } catch (err) {\n            res.status(500).json({ message: err.message });\n        }\n    });\n\n    // 4. Update a product by ID (PUT /api/products/:id)\n    app.put('/api/products/:id', async (req, res) => {\n        try {\n            const product = await Product.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });\n            if (!product) return res.status(404).json({ message: 'Product not found' });\n            res.json(product);\n        } catch (err) {\n            res.status(400).json({ message: err.message });\n        }\n    });\n\n    // 5. Delete a product by ID (DELETE /api/products/:id)\n    app.delete('/api/products/:id', async (req, res) => {\n        try {\n            const product = await Product.findByIdAndDelete(req.params.id);\n            if (!product) return res.status(404).json({ message: 'Product not found' });\n            res.json({ message: 'Product deleted successfully' });\n        } catch (err) {\n            res.status(500).json({ message: err.message });\n        }\n    });\n\n    const PORT = process.env.PORT || 3000;\n    app.listen(PORT, () => console.log(`Server running on port ${PORT}`));\n    ```\n\n**To Run:**\n1.  Ensure your MongoDB server is running.\n2.  Navigate to your `product-backend` directory in the terminal.\n3.  Run `node server.js`.\n4.  Test with a tool like Postman or Insomnia:\n    * **POST** `http://localhost:3000/api/products` with JSON body:\n        ```json\n        {\n            \"name\": \"Smartphone X\",\n            \"description\": \"Latest model with advanced camera.\",\n            \"price\": 799.99,\n            \"category\": \"Electronics\",\n            \"stock\": 150\n        }\n        ```\n    * **GET** `http://localhost:3000/api/products` to see all products.\n    * **GET** `http://localhost:3000/api/products/YOUR_PRODUCT_ID` (replace ID from POST response).\n\nThis example demonstrates how a mobile backend connects to a database, defines a data structure, and exposes a RESTful API for mobile clients to perform CRUD operations on `Product` data.\n\n### 6. Summary: Key Takeaways\n\n* Databases are the foundation of any mobile backend, storing and managing all application data.\n* The choice between **Relational (SQL)** and **Non-Relational (NoSQL)** databases depends heavily on your application's data structure, scalability requirements, consistency needs, and development priorities.\n* **SQL databases** (e.g., PostgreSQL) offer strong consistency and structured data, ideal for complex relationships and transactional data.\n* **NoSQL databases** (e.g., MongoDB, Firebase) provide flexibility, horizontal scalability, and are often better suited for rapidly evolving, large-scale, or real-time data needs.\n* Effective **data modeling** is crucial regardless of the database type, but approaches differ significantly (normalization in SQL, denormalization in NoSQL).\n* **Libraries and ORMs/ODMs** like Mongoose (for MongoDB) simplify the interaction between your backend code and the database, abstracting away low-level details and facilitating faster development of robust data operations.\n* Always consider performance, scalability, consistency, and cost when making your database selection.",
                    video_url: "https://www.youtube.com/watch?v=W2Z7fbCLSTw",
                    video_url_embed: "https://www.youtube.com/embed/W2Z7fbCLSTw",
                    is_active: true,
                    is_study_case: false,
                    created_at: "2025-08-21T01:31:54.308Z",
                    updated_at: "2025-08-21T01:32:21.570Z",
                    progress: [
                        {
                            is_done: false
                        }
                    ]
                },
                {
                    id: "cmekq7o790007pk0ijxusbnfl",
                    course_id: "cmekq7o780003pk0ima09m3k7",
                    order_index: 4,
                    title: "Securing User Access and Data",
                    description: "This chapter focuses on implementing secure authentication and authorization mechanisms for your mobile backend. You'll learn about different authentication methods, including token-based authentication (like JWT) and OAuth. We will discuss how to securely manage user accounts, handle passwords, and protect sensitive data. Understanding authorization principles, such as role-based access control, is also covered. This knowledge is critical for preventing unauthorized access and ensuring data integrity. Implementing these security measures correctly is paramount for any production-ready mobile application.",
                    content: "## Chapter 4: Securing User Access and Data\n\n### 1. What: Securing User Access and Data\n\nIn the realm of mobile backend development, \"securing user access and data\" refers to the comprehensive set of practices and technologies used to ensure that only authorized users can interact with your mobile application's backend services and that all data, especially sensitive user information, is protected from unauthorized access, modification, or disclosure. This chapter delves into two fundamental pillars:\n* **Authentication:** The process of verifying a user's identity. It answers the question, \"Are you who you say you are?\" Common methods include username/password, social logins, and biometric authentication.\n* **Authorization:** The process of determining what an authenticated user is permitted to do. It answers the question, \"What are you allowed to access or perform?\" This often involves roles and permissions.\n\nCombined, these mechanisms form the bedrock of a secure mobile application, safeguarding both the backend infrastructure and the valuable data it handles.\n\n### 2. Why: Importance and Relevance\n\nImplementing robust security measures for user access and data is not merely a best practice; it is an absolute necessity for any production-ready mobile application.\n* **Preventing Unauthorized Access:** Without proper authentication and authorization, malicious actors could impersonate legitimate users, access sensitive functionalities, or compromise the integrity of your entire system.\n* **Protecting Sensitive Data:** Mobile applications often handle personal identifiable information (PII), financial data, health records, or other confidential user data. Security measures ensure this data is encrypted, stored securely, and only accessible by its rightful owner or authorized personnel. A data breach can lead to severe financial penalties, legal liabilities, and irreparable damage to user trust.\n* **Maintaining Data Integrity:** Security controls help prevent data tampering or corruption, ensuring that the information stored and processed by your backend remains accurate and reliable.\n* **Building User Trust:** Users are more likely to adopt and continue using applications they perceive as secure. A strong security posture reassures users that their data and privacy are respected.\n* **Compliance and Regulations:** Many industries are subject to strict data protection regulations (e.g., GDPR, CCPA, HIPAA). Adhering to security standards helps ensure compliance and avoids costly legal repercussions.\n\nNeglecting security can lead to devastating consequences, including data breaches, loss of user trust, reputational damage, and significant financial and legal penalties.\n\n### 3. Tools/Libraries\n\nThe choice of tools and libraries often depends on the backend technology stack you are using. Here are some common categories and examples:\n\n* **Authentication Frameworks/Libraries:**\n    * **Node.js (Express):** `Passport.js` (middleware for various authentication strategies), `jsonwebtoken` (for JWT).\n    * **Python (Django/Flask):** `Django REST Framework` (includes authentication components), `Flask-JWT-Extended`.\n    * **Java (Spring Boot):** `Spring Security`.\n    * **PHP (Laravel):** `Laravel Passport` (for OAuth2).\n* **Password Hashing Libraries:**\n    * `bcrypt.js` (Node.js)\n    * `PyJWT` and `passlib` (Python)\n    * `BCryptPasswordEncoder` (Java Spring Security)\n* **Managed Authentication Services (Cloud-based):**\n    * **AWS Cognito:** Provides user sign-up, sign-in, and access control for web and mobile apps.\n    * **Firebase Authentication:** Integrates easily with Firebase projects, supporting various authentication methods (email/password, social logins, phone number).\n    * **Auth0:** A popular identity management platform offering extensive authentication and authorization features.\n* **OAuth 2.0 / OpenID Connect Libraries:**\n    * Libraries specific to integrating with social providers (Google, Facebook, etc.) or generic OAuth client libraries.\n\n### 4. Steps/Concepts\n\nImplementing secure user access and data protection typically involves several interconnected concepts:\n\n#### 4.1. Authentication Mechanisms\n\n1.  **User Registration and Secure Password Storage:**\n    * When a new user registers, their password must never be stored in plain text. Instead, it should be hashed using a strong, one-way cryptographic hashing function (e.g., bcrypt, scrypt, Argon2) combined with a unique **salt**.\n    * The salt is a random string added to the password before hashing, making it harder for attackers to use rainbow tables or pre-computed hashes.\n    * The hashing process should be computationally intensive to deter brute-force attacks.\n2.  **User Login and Credential Verification:**\n    * During login, the user provides their username and password.\n    * The backend retrieves the stored hash and salt for that username, then hashes the provided password with the retrieved salt.\n    * The newly computed hash is compared to the stored hash. If they match, the user is authenticated.\n3.  **Token-Based Authentication (JWT - JSON Web Tokens):**\n    * Widely used for mobile APIs due to its stateless nature.\n    * Upon successful login, the backend generates a JWT, which is a compact, URL-safe means of representing claims to be transferred between two parties.\n    * A JWT consists of three parts:\n        * **Header:** Specifies the token type (JWT) and the signing algorithm (e.g., HMAC SHA256).\n        * **Payload:** Contains claims (statements about an entity, typically the user). Common claims include `sub` (subject/user ID), `exp` (expiration time), `iat` (issued at time), and custom claims like user roles.\n        * **Signature:** Created by encoding the header and payload, and then signing it with a secret key known only to the server. This ensures the token's integrity and authenticity.\n    * The JWT is sent back to the client, which stores it (e.g., in `localStorage` or `AsyncStorage` for React Native).\n    * For subsequent requests, the client includes the JWT in the `Authorization` header (e.g., `Bearer <token>`).\n    * The backend verifies the token's signature using the secret key, checks its expiration, and extracts the user information from the payload without needing to query a database for every request (stateless).\n    * **Refresh Tokens:** To improve security and user experience, often a short-lived access token (JWT) is paired with a long-lived refresh token. When the access token expires, the client can use the refresh token to obtain a new access token without re-authenticating. Refresh tokens should be stored more securely and revoked if compromised.\n4.  **OAuth 2.0 and OpenID Connect:**\n    * **OAuth 2.0:** An authorization framework that enables applications to obtain limited access to user accounts on an HTTP service (e.g., Facebook, Google). It defines roles, authorization grants, and endpoints for interaction. It's about delegated authorization, not authentication itself.\n    * **OpenID Connect (OIDC):** An identity layer built on top of OAuth 2.0. It allows clients to verify the identity of the end-user based on the authentication performed by an authorization server, as well as to obtain basic profile information about the end-user. This is commonly used for \"Login with Google/Facebook\" features.\n\n#### 4.2. Authorization Principles\n\n1.  **Role-Based Access Control (RBAC):**\n    * Users are assigned specific **roles** (e.g., `admin`, `editor`, `viewer`, `customer`).\n    * Roles are granted specific **permissions** (e.g., `create_product`, `read_order`, `delete_user`).\n    * When an API endpoint is accessed, the backend checks the authenticated user's role(s) to determine if they have the necessary permissions to perform the requested action. This simplifies access management by grouping permissions.\n2.  **Attribute-Based Access Control (ABAC):**\n    * A more fine-grained approach where access decisions are made based on various attributes of the user (e.g., department, location), the resource (e.g., data sensitivity, owner), and the environment (e.g., time of day, IP address).\n    * While powerful, ABAC can be more complex to implement than RBAC. For most mobile backends, RBAC is sufficient.\n\n#### 4.3. Data Protection\n\n1.  **Encryption In Transit (HTTPS/TLS):** All communication between the mobile app and the backend *must* use HTTPS (HTTP Secure). TLS (Transport Layer Security) encrypts data as it travels over the network, preventing eavesdropping and man-in-the-middle attacks. Obtain a valid SSL/TLS certificate for your backend domain.\n2.  **Encryption At Rest:** Sensitive data stored in databases or file systems should be encrypted.\n    * **Database Encryption:** Many modern databases offer encryption-at-rest features (e.g., TDE - Transparent Data Encryption).\n    * **Disk Encryption:** Encrypting the entire disk where the database or sensitive files reside provides an additional layer of security.\n3.  **Sensitive Data Handling:**\n    * Never log sensitive user data (passwords, PII) in plain text.\n    * Sanitize and validate all user inputs to prevent injection attacks (SQL injection, XSS).\n    * Minimize the amount of sensitive data stored. If data is not needed, don't store it. If it must be stored, encrypt it.\n\n### 5. Real Example: Node.js (Express) JWT & RBAC\n\nLet's illustrate with a simplified Node.js Express backend using JWT for authentication and basic middleware for RBAC.\n\nFirst, install necessary packages:\n```bash\nnpm install express jsonwebtoken bcryptjs\n```\n\n**Project Structure (Simplified):**\n```\nserver.js\nroutes/\n  auth.js\n  protected.js\nmiddleware/\n  auth.js\n  role.js\n```\n\n#### `server.js` (Main Application File)\n\n```javascript\nconst express = require('express');\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Import routes\nconst authRoutes = require('./routes/auth');\nconst protectedRoutes = require('./routes/protected');\n\n// Middleware to parse JSON bodies\napp.use(express.json());\n\n// Basic user \"database\" (for demonstration purposes only, use a real DB in production)\napp.locals.users = []; // Array to store user objects: { id, username, passwordHash, role }\n\n// Register authentication routes\napp.use('/api/auth', authRoutes);\n\n// Register protected routes (will require authentication)\napp.use('/api/protected', protectedRoutes);\n\napp.get('/', (req, res) => {\n  res.send('Mobile Backend Security Demo');\n});\n\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```\n\n#### `middleware/auth.js` (JWT Authentication Middleware)\n\n```javascript\nconst jwt = require('jsonwebtoken');\n\nconst JWT_SECRET = 'your_jwt_secret_key'; // CHANGE THIS IN PRODUCTION! Use environment variables.\n\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Expected format: 'Bearer TOKEN'\n\n  if (token == null) {\n    return res.sendStatus(401); // No token provided\n  }\n\n  jwt.verify(token, JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.sendStatus(403); // Token invalid or expired\n    }\n    req.user = user; // Store decoded user payload in request object\n    next();\n  });\n};\n\nmodule.exports = authenticateToken;\n```\n\n#### `middleware/role.js` (Role-Based Access Control Middleware)\n\n```javascript\nconst authorizeRoles = (...allowedRoles) => {\n  return (req, res, next) => {\n    if (!req.user || !req.user.role) {\n      return res.sendStatus(403); // User not authenticated or role not set\n    }\n\n    const rolesArray = [...allowedRoles];\n    const userRole = req.user.role;\n\n    if (!rolesArray.includes(userRole)) {\n      return res.status(403).json({ message: 'Insufficient permissions' });\n    }\n    next();\n  };\n};\n\nmodule.exports = authorizeRoles;\n```\n\n#### `routes/auth.js` (User Authentication Routes)\n\n```javascript\nconst express = require('express');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst router = express.Router();\n\nconst JWT_SECRET = 'your_jwt_secret_key'; // CHANGE THIS IN PRODUCTION!\nconst SALT_ROUNDS = 10;\n\n// Dummy user data - In production, use a database (e.g., MongoDB, PostgreSQL)\n// This array will be populated by the `app.locals.users` from server.js\nlet users; \n\n// Middleware to access app.locals.users\nrouter.use((req, res, next) => {\n  users = req.app.locals.users;\n  next();\n});\n\n// User Registration\nrouter.post('/register', async (req, res) => {\n  const { username, password, role = 'user' } = req.body;\n\n  if (!username || !password) {\n    return res.status(400).json({ message: 'Username and password are required' });\n  }\n\n  if (users.find(u => u.username === username)) {\n    return res.status(409).json({ message: 'Username already exists' });\n  }\n\n  try {\n    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);\n    const newUser = {\n      id: users.length + 1,\n      username,\n      passwordHash,\n      role // Default to 'user', can be 'admin' if specified\n    };\n    users.push(newUser);\n    res.status(201).json({ message: 'User registered successfully', user: { id: newUser.id, username: newUser.username, role: newUser.role } });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Error registering user' });\n  }\n});\n\n// User Login\nrouter.post('/login', async (req, res) => {\n  const { username, password } = req.body;\n\n  if (!username || !password) {\n    return res.status(400).json({ message: 'Username and password are required' });\n  }\n\n  const user = users.find(u => u.username === username);\n  if (!user) {\n    return res.status(400).json({ message: 'Invalid credentials' });\n  }\n\n  try {\n    const isMatch = await bcrypt.compare(password, user.passwordHash);\n    if (!isMatch) {\n      return res.status(400).json({ message: 'Invalid credentials' });\n    }\n\n    // Generate JWT\n    const accessToken = jwt.sign(\n      { id: user.id, username: user.username, role: user.role },\n      JWT_SECRET,\n      { expiresIn: '1h' } // Token expires in 1 hour\n    );\n\n    res.json({ accessToken });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({ message: 'Error logging in' });\n  }\n});\n\nmodule.exports = router;\n```\n\n#### `routes/protected.js` (Protected Routes)\n\n```javascript\nconst express = require('express');\nconst authenticateToken = require('../middleware/auth');\nconst authorizeRoles = require('../middleware/role');\nconst router = express.Router();\n\n// This route is accessible by any authenticated user\nrouter.get('/profile', authenticateToken, (req, res) => {\n  res.json({\n    message: `Welcome, ${req.user.username}! This is your profile.`,\n    user: { id: req.user.id, username: req.user.username, role: req.user.role }\n  });\n});\n\n// This route is only accessible by users with 'admin' role\nrouter.get('/admin-dashboard', authenticateToken, authorizeRoles('admin'), (req, res) => {\n  res.json({ message: `Welcome, Admin ${req.user.username}! This is the admin dashboard.` });\n});\n\n// This route is accessible by 'admin' or 'editor' roles\nrouter.post('/content', authenticateToken, authorizeRoles('admin', 'editor'), (req, res) => {\n  res.json({ message: `Content created by ${req.user.username} with role ${req.user.role}.` });\n});\n\nmodule.exports = router;\n```\n\n**How to Test:**\n1.  Run the server: `node server.js`\n2.  Use a tool like Postman or Insomnia:\n    * **Register a user:** `POST /api/auth/register`\n        * Body (JSON): `{\"username\": \"testuser\", \"password\": \"password123\", \"role\": \"user\"}`\n        * Body (JSON): `{\"username\": \"adminuser\", \"password\": \"adminpassword\", \"role\": \"admin\"}`\n    * **Login:** `POST /api/auth/login`\n        * Body (JSON): `{\"username\": \"testuser\", \"password\": \"password123\"}` -> Get `accessToken`\n    * **Access Protected Profile:** `GET /api/protected/profile`\n        * Headers: `Authorization: Bearer <your_access_token>`\n    * **Try Admin Dashboard (as 'testuser'):** `GET /api/protected/admin-dashboard`\n        * Headers: `Authorization: Bearer <testuser_access_token>` (should get 403 Forbidden)\n    * **Try Admin Dashboard (as 'adminuser'):** `GET /api/protected/admin-dashboard`\n        * Headers: `Authorization: Bearer <adminuser_access_token>` (should get 200 OK)\n\nThis example demonstrates the core concepts of secure password storage, JWT-based authentication, and role-based authorization for API endpoints.\n\n### 6. Summary: Key Takeaways\n\n* **Authentication** verifies who a user is, while **Authorization** determines what they can do. Both are critical for mobile backend security.\n* Always use strong, one-way **hashing with salts** (e.g., bcrypt) for storing user passwords; never store them in plain text.\n* **Token-based authentication**, particularly using **JWTs**, is ideal for stateless mobile API backends. Remember to manage token expiration and consider using refresh tokens.\n* Implement **Role-Based Access Control (RBAC)** to define and enforce user permissions, ensuring users can only access resources and perform actions relevant to their assigned roles.\n* **Encrypt all data in transit using HTTPS/TLS** to protect against eavesdropping and tampering.\n* Practice **secure data handling** by minimizing sensitive data storage, encrypting data at rest, and rigorously validating all user inputs to prevent common attack vectors like injection flaws.",
                    video_url: "https://www.youtube.com/watch?v=yTWWjr6co1E",
                    video_url_embed: "https://www.youtube.com/embed/yTWWjr6co1E",
                    is_active: true,
                    is_study_case: false,
                    created_at: "2025-08-21T01:31:54.308Z",
                    updated_at: "2025-08-21T01:32:23.883Z",
                    progress: [
                        {
                            is_done: false
                        }
                    ]
                },
                {
                    id: "cmekq7o790008pk0ikc42igzk",
                    course_id: "cmekq7o780003pk0ima09m3k7",
                    order_index: 5,
                    title: "Leveraging Cloud Services for Scalability",
                    description: "This chapter introduces popular cloud platforms that streamline mobile backend development and deployment. We will explore services offered by platforms like AWS Amplify, Google Cloud Firebase, and Microsoft Azure Mobile Apps. You'll learn about the benefits of using serverless functions, managed databases, and content delivery networks. We'll discuss how these services can help your backend scale automatically to handle varying loads. Understanding cloud deployment models is essential for building scalable and cost-effective mobile solutions. This chapter provides an overview of modern cloud strategies for backend engineers.",
                    content: "## Chapter 5: Leveraging Cloud Services for Scalability\n\n### 1. What are Cloud Services for Mobile Back Ends?\n\nCloud services represent a paradigm shift in how we design, build, and deploy software, especially for mobile backends. Instead of managing physical servers and infrastructure, developers can leverage computing resources (servers, databases, storage, networking, analytics, etc.) as a service over the internet. For mobile applications, this means abstracting away the complexities of server management, scaling, and maintenance, allowing developers to focus purely on application logic and user experience.\n\nPopular cloud platforms like Amazon Web Services (AWS), Google Cloud Platform (GCP) with its specialized Firebase suite, and Microsoft Azure offer a comprehensive ecosystem of services tailored for mobile backend needs. These services range from serverless functions that execute code on demand, to fully managed databases that handle scalability and replication automatically, and content delivery networks (CDNs) that ensure fast content delivery globally.\n\n### 2. Why Use Cloud Services for Mobile Back Ends?\n\nThe adoption of cloud services for mobile backends is driven by several compelling advantages:\n\n* **Automatic Scalability:** Mobile applications can experience unpredictable spikes in user traffic. Cloud services are designed to scale resources automatically (or with minimal configuration) to meet demand, ensuring your backend remains responsive without manual intervention or over-provisioning.\n* **Cost-Effectiveness:** Many cloud services operate on a pay-as-you-go model, often with a serverless execution model where you only pay for the compute time and resources consumed. This eliminates the need for large upfront capital expenditures on hardware and reduces operational costs, especially for applications with fluctuating loads.\n* **Reduced Operational Overhead:** Managing servers, operating systems, databases, and network infrastructure is complex and time-consuming. Cloud providers handle these underlying tasks, including patching, backups, and high availability, freeing developers to focus on product features.\n* **Faster Development and Deployment:** Pre-built services like authentication, managed databases, and API gateways significantly accelerate development cycles. Developers can integrate these services quickly rather than building them from scratch. CI/CD (Continuous Integration/Continuous Deployment) pipelines are also easier to set up on cloud platforms.\n* **Global Reach and Low Latency:** Cloud providers have data centers worldwide. Leveraging CDNs and geographically distributed databases ensures that your application's data and content are delivered quickly to users, regardless of their location, enhancing the user experience.\n* **Enhanced Reliability and Security:** Cloud platforms are built for high availability and disaster recovery. They invest heavily in security infrastructure, compliance, and best practices, often providing a more secure environment than what individual teams can achieve on their own.\n\n### 3. Key Cloud Tools and Libraries\n\nModern cloud platforms offer a rich set of services that are invaluable for mobile backend development:\n\n* **AWS (Amazon Web Services):**\n    * **AWS Amplify:** A set of tools and services to build scalable mobile and web applications, offering simplified integration with services like Authentication (`Cognito`), Database (`DynamoDB`, `AppSync`), Serverless APIs (`API Gateway`, `Lambda`), and Storage (`S3`).\n    * **AWS Lambda:** A serverless compute service that runs code in response to events without provisioning or managing servers. Ideal for API endpoints, data processing, and backend logic.\n    * **Amazon DynamoDB:** A fast, flexible NoSQL database service for single-digit millisecond performance at any scale.\n    * **Amazon S3 (Simple Storage Service):** Object storage built to store and retrieve any amount of data from anywhere on the web. Perfect for user-generated content, images, and videos.\n    * **Amazon API Gateway:** A fully managed service that makes it easy for developers to create, publish, maintain, monitor, and secure APIs at any scale.\n    * **Amazon CloudFront:** A fast content delivery network (CDN) service that securely delivers data, videos, applications, and APIs to customers globally with low latency.\n\n* **Google Cloud Platform (GCP) / Firebase:**\n    * **Firebase:** Google's comprehensive platform for mobile and web development. It provides many backend services as a service.\n        * **Firestore:** A flexible, scalable NoSQL cloud database for mobile, web, and server development. It offers real-time data synchronization.\n        * **Cloud Functions for Firebase:** A serverless framework to run backend code in response to events triggered by Firebase features and HTTPS requests.\n        * **Firebase Authentication:** Fully managed service for user authentication, supporting various providers (email/password, Google, Facebook, etc.).\n        * **Firebase Storage:** Robust object storage for user-generated content, backed by Google Cloud Storage.\n        * **Firebase Hosting:** Fast and secure hosting for web apps, including those that power mobile webviews or API entry points.\n    * **Google Cloud Run:** A fully managed compute platform that enables you to run stateless containers via web requests or Pub/Sub events. Offers more flexibility than pure functions while maintaining serverless properties.\n    * **Google Cloud SQL:** A fully managed relational database service for MySQL, PostgreSQL, and SQL Server.\n\n* **Microsoft Azure:**\n    * **Azure Mobile Apps:** A service that provides a highly scalable, globally available backend for mobile applications, including authentication, push notifications, and offline data sync.\n    * **Azure Functions:** Serverless compute service similar to AWS Lambda and Google Cloud Functions.\n    * **Azure Cosmos DB:** Microsoft's globally distributed, multi-model database service (supports NoSQL APIs like SQL, MongoDB, Cassandra, Gremlin, and Table).\n    * **Azure Blob Storage:** Microsoft's object storage solution for the cloud.\n\nDevelopers often use SDKs (Software Development Kits) provided by these platforms (e.g., AWS SDKs, Firebase SDKs) and command-line interface (CLI) tools for development and deployment.\n\n### 4. Core Concepts and Deployment Models\n\nUnderstanding the fundamental concepts behind cloud services is crucial for designing scalable mobile backends.\n\n* **Serverless Functions (Function as a Service - FaaS):**\n    * **Concept:** This model allows you to deploy individual functions that execute code in response to specific events (e.g., an HTTP request, a database change, a file upload). The cloud provider fully manages the underlying servers.\n    * **Benefits:** Auto-scaling, pay-per-execution (you only pay when your function runs), reduced operational burden, rapid deployment of small, focused backend logic.\n    * **Examples:** AWS Lambda, Google Cloud Functions, Azure Functions.\n    * **Use Case:** Ideal for building REST APIs, processing image uploads, sending push notifications, or handling webhook events.\n\n* **Managed Databases:**\n    * **Concept:** Cloud providers offer databases as a service, abstracting away server setup, patching, backups, replication, and scaling.\n    * **Benefits:** High availability, automatic backups, seamless scaling (both vertically and horizontally), reduced DBA overhead, built-in security features.\n    * **Examples:** Amazon DynamoDB (NoSQL), Google Firestore (NoSQL), Azure Cosmos DB (NoSQL), Google Cloud SQL (Relational), Amazon RDS (Relational).\n    * **Considerations:** Choose between NoSQL (e.g., for flexible schemas, high write throughput) and SQL (e.g., for complex queries, strong consistency) based on your application's data model and access patterns.\n\n* **Content Delivery Networks (CDNs):**\n    * **Concept:** A geographically distributed network of proxy servers and their data centers. When a user requests content, the CDN delivers it from the closest server location, minimizing latency.\n    * **Benefits:** Faster content delivery (images, videos, static files), reduced load on your origin server, improved user experience, enhanced reliability.\n    * **Examples:** Amazon CloudFront, Google Cloud CDN, Azure CDN.\n    * **Use Case:** Essential for mobile apps that serve a lot of static assets or user-generated media.\n\n* **Authentication as a Service:**\n    * **Concept:** Managed services that handle user registration, login, session management, and multi-factor authentication (MFA). They often integrate with social identity providers (Google, Facebook, Apple).\n    * **Benefits:** Reduces development time and security risk associated with building and maintaining your own authentication system.\n    * **Examples:** AWS Amplify Auth (powered by Cognito), Firebase Authentication.\n\n* **API Management/Gateways:**\n    * **Concept:** Services that act as a single entry point for all your APIs. They handle routing, security (e.g., API keys, OAuth), rate limiting, caching, and monitoring.\n    * **Benefits:** Centralized API governance, improved security, better performance, simplified client integration.\n    * **Examples:** Amazon API Gateway, Azure API Management. Cloud Functions and Firebase Hosting often serve as implicit API gateways for their respective platforms.\n\n* **Deployment Models:**\n    * **PaaS (Platform as a Service):** You deploy your application code, and the platform manages the underlying infrastructure (OS, runtime, middleware). Examples include Heroku, Google App Engine, and some aspects of Azure App Service.\n    * **FaaS (Function as a Service / Serverless Compute):** The most granular form of PaaS, where you deploy individual functions. The platform scales and manages everything.\n    * **Containers (e.g., Docker on Cloud Run/ECS/AKS):** While not strictly serverless by definition (you define a container image), services like Google Cloud Run or AWS Fargate bring serverless-like operational benefits to containerized applications, offering more control than pure FaaS while retaining auto-scaling and pay-per-use billing.\n\n### 5. Real Example: Building a Serverless API with Firebase\n\nLet's illustrate how to build a simple serverless backend for a to-do list mobile application using Firebase, leveraging Firestore for data storage, Firebase Authentication for user management, and Cloud Functions for API logic.\n\n**Scenario:** A mobile app where users can add and retrieve their personal to-do items. Each user should only see their own items.\n\n**Services Used:**\n* **Firebase Authentication:** To manage user accounts and ensure only authenticated users can interact with the API.\n* **Cloud Firestore:** A NoSQL database to store to-do items. Each item will include a `userId` field to link it to the creator.\n* **Cloud Functions for Firebase:** To expose serverless API endpoints (HTTPS callable functions) for adding and retrieving to-do items.\n\n**Setup (Conceptual Steps):**\n1.  Create a Firebase project.\n2.  Enable Firebase Authentication (e.g., Email/Password or Google Sign-In).\n3.  Initialize Cloud Firestore.\n4.  Set up Cloud Functions environment.\n\n**Cloud Functions Code (`functions/index.js`):**\n\n```javascript\nconst functions = require('firebase-functions');\nconst admin = require('firebase-admin');\nadmin.initializeApp(); // Initializes Firebase Admin SDK\n\n// Firestore database reference\nconst db = admin.firestore();\n\n/**\n * Cloud Function to add a new to-do item for the authenticated user.\n *\n * This function expects a JSON payload with a 'text' field representing the to-do item.\n * It's an HTTPS Callable Function, meaning it can be called directly from a mobile client\n * using the Firebase SDK, which handles authentication context automatically.\n */\nexports.addTodo = functions.https.onCall(async (data, context) => {\n  // 1. Check if the user is authenticated\n  if (!context.auth) {\n    // Throwing an HttpsError will send an error response to the client\n    throw new functions.https.HttpsError(\n      'unauthenticated',\n      'The function must be called while authenticated.'\n    );\n  }\n\n  // 2. Validate input: Ensure 'text' is provided and is a non-empty string\n  const text = data.text;\n  if (!(typeof text === 'string') || text.length === 0) {\n    throw new functions.https.HttpsError(\n      'invalid-argument',\n      'The function must be called with a \"text\" argument that is a non-empty string.'\n    );\n  }\n\n  // 3. Get the authenticated user's ID\n  const userId = context.auth.uid;\n\n  // 4. Store the new to-do item in Firestore\n  try {\n    const docRef = await db.collection('todos').add({\n      userId: userId,           // Link to the user who created it\n      text: text,             // The to-do item description\n      createdAt: admin.firestore.FieldValue.serverTimestamp(), // Server timestamp for creation time\n      completed: false         // Initial status\n    });\n    console.log(`Todo added with ID: ${docRef.id} for user: ${userId}`);\n    return { id: docRef.id, message: 'Todo added successfully!' };\n  } catch (error) {\n    console.error('Error adding todo:', error);\n    throw new functions.https.HttpsError(\n      'internal',\n      'Failed to add todo: ' + error.message\n    );\n  }\n});\n\n/**\n * Cloud Function to retrieve all to-do items for the authenticated user.\n *\n * This is also an HTTPS Callable Function. It fetches documents from Firestore\n * where the 'userId' field matches the authenticated user's ID.\n */\nexports.getTodos = functions.https.onCall(async (data, context) => {\n    // 1. Check if the user is authenticated\n    if (!context.auth) {\n        throw new functions.https.HttpsError(\n            'unauthenticated',\n            'The function must be called while authenticated.'\n        );\n    }\n\n    // 2. Get the authenticated user's ID\n    const userId = context.auth.uid;\n\n    // 3. Query Firestore for todos belonging to this user, ordered by creation time\n    try {\n        const snapshot = await db.collection('todos')\n            .where('userId', '==', userId)\n            .orderBy('createdAt', 'desc') // Order by most recent first\n            .get();\n\n        // 4. Map the documents to a clean array of todo objects\n        const todos = snapshot.docs.map(doc => ({\n            id: doc.id,\n            ...doc.data() // Spreads all fields from the document\n        }));\n\n        console.log(`Retrieved ${todos.length} todos for user: ${userId}`);\n        return { todos }; // Return the array of todos\n    } catch (error) {\n        console.error('Error retrieving todos:', error);\n        throw new functions.https.HttpsError(\n            'internal',\n            'Failed to retrieve todos: ' + error.message\n        );\n    }\n});\n```\n\n**Deployment:**\nAfter writing the code, you would deploy these functions using the Firebase CLI:\n`firebase deploy --only functions`\n\n**Client-Side (Mobile App - e.g., JavaScript/TypeScript for React Native or Flutter):**\nOn the mobile app side, after a user logs in (e.g., using `firebase.auth().signInWithEmailAndPassword()`), you can call these functions:\n\n```javascript\n// Example of calling the addTodo function from a mobile client (e.g., React Native)\nimport functions from '@react-native-firebase/functions';\nimport auth from '@react-native-firebase/auth';\n\nasync function addNewTodo(todoText) {\n  try {\n    // Get a reference to the callable function\n    const addTodoCallable = functions().httpsCallable('addTodo');\n\n    // Call the function with the data payload\n    const result = await addTodoCallable({ text: todoText });\n\n    console.log('Todo added:', result.data); // result.data contains { id: ..., message: ... }\n    return result.data;\n  } catch (error) {\n    console.error('Error calling addTodo function:', error.code, error.message);\n    // Handle error, e.g., show an alert to the user\n    throw error;\n  }\n}\n\n// Example of calling the getTodos function\nasync function getUserTodos() {\n  try {\n    const getTodosCallable = functions().httpsCallable('getTodos');\n    const result = await getTodosCallable();\n\n    console.log('User todos:', result.data.todos); // result.data.todos contains the array of todo objects\n    return result.data.todos;\n  } catch (error) {\n    console.error('Error calling getTodos function:', error.code, error.message);\n    throw error;\n  }\n}\n\n// Ensure a user is logged in before calling these functions\n// For instance, after auth().signInAnonymously() or auth().signInWithEmailAndPassword()\n// You can listen to auth().onAuthStateChanged()\nif (auth().currentUser) {\n    addNewTodo('Learn Cloud Functions');\n    getUserTodos();\n} else {\n    console.log('Please log in first.');\n}\n```\n\nThis example demonstrates how serverless functions combined with managed database and authentication services simplify backend development. The functions automatically scale with user load, and you don't manage any servers.\n\n### 6. Summary\n\nLeveraging cloud services is fundamental for building scalable, robust, and cost-effective mobile backends in today's landscape. By offloading infrastructure management to cloud providers, developers can significantly accelerate development cycles and focus on delivering core application features.\n\nWe explored key cloud platforms like AWS, Google Cloud (Firebase), and Azure, and highlighted their core services: serverless functions (`AWS Lambda`, `Cloud Functions`, `Azure Functions`), managed databases (`DynamoDB`, `Firestore`, `Cosmos DB`), and content delivery networks (`CloudFront`, `Cloud CDN`). These services inherently provide auto-scaling, high availability, and reduced operational overhead.\n\nUnderstanding these cloud deployment models and the tools available is essential for any mobile backend engineer aiming to build solutions that can grow seamlessly with their user base and adapt to fluctuating demands. The shift towards serverless and managed services represents a modern, efficient strategy for powering mobile applications.",
                    video_url: "https://www.youtube.com/watch?v=UKYkY4INJQs",
                    video_url_embed: "https://www.youtube.com/embed/UKYkY4INJQs",
                    is_active: true,
                    is_study_case: false,
                    created_at: "2025-08-21T01:31:54.308Z",
                    updated_at: "2025-08-21T01:32:26.315Z",
                    progress: [
                        {
                            is_done: false
                        }
                    ]
                },
                {
                    id: "cmekq7o790009pk0i95xapynl",
                    course_id: "cmekq7o780003pk0ima09m3k7",
                    order_index: 6,
                    title: "Case Study: Developing a Basic E-commerce Backend",
                    description: "This final chapter consolidates the concepts learned throughout the course into a practical case study. We will outline the process of building a simple backend for a hypothetical e-commerce mobile application. This includes designing APIs for products, orders, and user management, and selecting appropriate database solutions. You'll see how authentication and authorization principles are applied in a real-world scenario. The chapter will also touch upon considerations for deployment on a cloud platform. This hands-on example demonstrates how different backend components work together to support a mobile application. It serves as a comprehensive review and practical application of the skills acquired.",
                    content: "## Chapter 6: Case Study: Developing a Basic E-commerce Backend\n\n### 1. What: Introduction to the Study Case\n\nThis final chapter serves as a practical capstone, consolidating the concepts of API design, database integration, authentication, and deployment into a tangible project. We will embark on building a basic backend for a hypothetical e-commerce mobile application. The goal is to provide the necessary server-side infrastructure to support core e-commerce functionalities, including managing a product catalog, handling user accounts (registration, login), and processing customer orders. This case study focuses on creating robust and scalable APIs that mobile applications can consume, offering a comprehensive review and practical application of the skills you've acquired throughout this course.\n\n### 2. Why: Importance and Relevance of the Study Case\n\nDeveloping an e-commerce backend offers an excellent real-world scenario to apply your mobile backend development skills.\n\n* **Holistic Application:** It requires integrating nearly all concepts learned previously: API design for multiple resources (users, products, orders), choosing and interacting with a database, implementing secure user authentication and authorization, and preparing for deployment.\n* **Industry Relevance:** E-commerce is a dominant sector in mobile applications. Understanding its backend architecture provides valuable insights and hands-on experience applicable to a wide range of similar projects.\n* **Problem-Solving:** You'll face practical challenges such as defining relationships between different data entities, handling user sessions securely, and designing efficient data retrieval mechanisms, fostering critical problem-solving skills.\n* **Foundation for Expansion:** While \"basic,\" this project serves as a solid foundation. You'll easily see how features like payment integration, search, recommendations, or complex inventory management could be added, preparing you for more advanced backend development.\n* **Demonstrable Project:** Completing this case study provides a tangible project that can be showcased, proving your ability to build functional mobile backends.\n\n### 3. Tools/Libraries\n\nFor this case study, we will leverage a popular and efficient stack commonly used in mobile backend development:\n\n* **Backend Framework:** `Node.js` with `Express.js`. Express provides a minimalist and flexible framework for building RESTful APIs.\n* **Database:** `MongoDB`. A NoSQL document database, MongoDB offers flexibility and scalability, fitting well with the dynamic nature of e-commerce data. We will use `Mongoose` as an Object Data Modeling (ODM) library for Node.js, simplifying interactions with MongoDB.\n* **Authentication:** `JSON Web Tokens (JWT)`. JWTs provide a secure and stateless way to handle user authentication and authorization, ideal for mobile applications.\n* **Password Hashing:** `bcrypt.js`. Essential for securely storing user passwords.\n* **Environment Variables:** `dotenv`. To manage sensitive configurations (like database URIs, JWT secrets) outside of the codebase.\n* **Deployment (Optional but Recommended):** Cloud platforms like `Heroku` or `Render` (Platform as a Service - PaaS) or `Vercel` (for serverless functions if using a different architecture) for easy deployment and scaling. For MongoDB, `MongoDB Atlas` (cloud database service) is highly recommended.\n\n### 4. Steps/Concepts\n\nHere's an ordered breakdown of the steps to develop our basic e-commerce backend:\n\n#### 4.1 Project Setup and Initial Configuration\n\n1.  **Initialize Node.js Project:** Create a new directory for your project and initialize it:\n    ```bash\n    mkdir ecommerce-backend\n    cd ecommerce-backend\n    npm init -y\n    ```\n2.  **Install Dependencies:** Install `express`, `mongoose`, `dotenv`, `bcryptjs`, and `jsonwebtoken`.\n    ```bash\n    npm install express mongoose dotenv bcryptjs jsonwebtoken\n    ```\n3.  **Basic Server Setup:** Create an `app.js` (or `server.js`) file to set up your Express application and connect to the database.\n    ```javascript\n    // app.js\n    require('dotenv').config(); // Load environment variables\n    const express = require('express');\n    const mongoose = require('mongoose');\n    const app = express();\n    const PORT = process.env.PORT || 5000;\n\n    // Middleware to parse JSON bodies\n    app.use(express.json());\n\n    // Connect to MongoDB\n    mongoose.connect(process.env.MONGO_URI, {\n        useNewUrlParser: true,\n        useUnifiedTopology: true,\n    })\n    .then(() => console.log('MongoDB connected successfully'))\n    .catch(err => console.error('MongoDB connection error:', err));\n\n    // Basic route\n    app.get('/', (req, res) => {\n        res.send('E-commerce Backend API is running!');\n    });\n\n    // Start the server\n    app.listen(PORT, () => {\n        console.log(`Server running on port ${PORT}`);\n    });\n    ```\n4.  **Environment Variables:** Create a `.env` file in your root directory for sensitive information.\n    ```\n    PORT=5000\n    MONGO_URI=mongodb+srv://<username>:<password>@cluster0.abcde.mongodb.net/ecommerce?retryWrites=true&w=majority\n    JWT_SECRET=your_jwt_secret_key\n    ```\n    *(Remember to replace `<username>`, `<password>`, and `cluster0.abcde` with your MongoDB Atlas details. Also, generate a strong, random `JWT_SECRET`.)*\n\n#### 4.2 Database Design and Models\n\nDefine Mongoose schemas for the core entities: `User`, `Product`, and `Order`. Create a `models` directory.\n\n1.  **User Model (`models/User.js`):**\n    ```javascript\n    // models/User.js\n    const mongoose = require('mongoose');\n    const bcrypt = require('bcryptjs');\n\n    const UserSchema = new mongoose.Schema({\n        username: { type: String, required: true, unique: true },\n        email: { type: String, required: true, unique: true },\n        password: { type: String, required: true },\n        role: { type: String, enum: ['user', 'admin'], default: 'user' }\n    }, { timestamps: true });\n\n    // Hash password before saving\n    UserSchema.pre('save', async function(next) {\n        if (!this.isModified('password')) return next();\n        const salt = await bcrypt.genSalt(10);\n        this.password = await bcrypt.hash(this.password, salt);\n        next();\n    });\n\n    // Method to compare password\n    UserSchema.methods.matchPassword = async function(enteredPassword) {\n        return await bcrypt.compare(enteredPassword, this.password);\n    };\n\n    module.exports = mongoose.model('User', UserSchema);\n    ```\n2.  **Product Model (`models/Product.js`):**\n    ```javascript\n    // models/Product.js\n    const mongoose = require('mongoose');\n\n    const ProductSchema = new mongoose.Schema({\n        name: { type: String, required: true },\n        description: { type: String, required: true },\n        price: { type: Number, required: true, default: 0 },\n        stock: { type: Number, required: true, default: 0 },\n        imageUrl: { type: String, default: 'no-image.jpg' }\n    }, { timestamps: true });\n\n    module.exports = mongoose.model('Product', ProductSchema);\n    ```\n3.  **Order Model (`models/Order.js`):**\n    ```javascript\n    // models/Order.js\n    const mongoose = require('mongoose');\n\n    const OrderSchema = new mongoose.Schema({\n        user: {\n            type: mongoose.Schema.Types.ObjectId,\n            required: true,\n            ref: 'User' // Reference to the User model\n        },\n        items: [\n            {\n                product: {\n                    type: mongoose.Schema.Types.ObjectId,\n                    required: true,\n                    ref: 'Product' // Reference to the Product model\n                },\n                quantity: { type: Number, required: true, default: 1 }\n            }\n        ],\n        totalAmount: { type: Number, required: true, default: 0 },\n        status: {\n            type: String,\n            enum: ['pending', 'processing', 'shipped', 'delivered', 'cancelled'],\n            default: 'pending'\n        }\n    }, { timestamps: true });\n\n    module.exports = mongoose.model('Order', OrderSchema);\n    ```\n\n#### 4.3 Implementing Authentication and Authorization\n\nCreate a `middleware` directory for authentication and authorization logic.\n\n1.  **Authentication Middleware (`middleware/authMiddleware.js`):**\n    This middleware will verify JWTs and attach the authenticated user to the request object.\n    ```javascript\n    // middleware/authMiddleware.js\n    const jwt = require('jsonwebtoken');\n    const User = require('../models/User');\n\n    const protect = async (req, res, next) => {\n        let token;\n        if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n            try {\n                token = req.headers.authorization.split(' ')[1];\n                const decoded = jwt.verify(token, process.env.JWT_SECRET);\n                req.user = await User.findById(decoded.id).select('-password'); // Exclude password\n                next();\n            } catch (error) {\n                console.error(error);\n                res.status(401).json({ message: 'Not authorized, token failed' });\n            }\n        }\n        if (!token) {\n            res.status(401).json({ message: 'Not authorized, no token' });\n        }\n    };\n\n    const authorizeRoles = (...roles) => {\n        return (req, res, next) => {\n            if (!req.user || !roles.includes(req.user.role)) {\n                return res.status(403).json({ message: `User role ${req.user.role} is not authorized to access this route` });\n            }\n            next();\n        };\n    };\n\n    module.exports = { protect, authorizeRoles };\n    ```\n\n#### 4.4 API Design and Endpoints\n\nOrganize your routes and controllers in separate directories (`routes`, `controllers`).\n\n1.  **User Routes (`routes/userRoutes.js`) and Controller (`controllers/userController.js`):**\n    * **Register User:** `POST /api/users/register`\n    * **Login User:** `POST /api/users/login`\n    * **Get User Profile:** `GET /api/users/profile` (Protected)\n\n    ```javascript\n    // controllers/userController.js\n    const User = require('../models/User');\n    const jwt = require('jsonwebtoken');\n\n    const generateToken = (id) => {\n        return jwt.sign({ id }, process.env.JWT_SECRET, { expiresIn: '1h' });\n    };\n\n    const registerUser = async (req, res) => {\n        const { username, email, password } = req.body;\n        try {\n            const userExists = await User.findOne({ email });\n            if (userExists) return res.status(400).json({ message: 'User already exists' });\n\n            const user = await User.create({ username, email, password });\n            res.status(201).json({\n                _id: user._id,\n                username: user.username,\n                email: user.email,\n                role: user.role,\n                token: generateToken(user._id)\n            });\n        } catch (error) {\n            res.status(500).json({ message: error.message });\n        }\n    };\n\n    const loginUser = async (req, res) => {\n        const { email, password } = req.body;\n        try {\n            const user = await User.findOne({ email });\n            if (user && (await user.matchPassword(password))) {\n                res.json({\n                    _id: user._id,\n                    username: user.username,\n                    email: user.email,\n                    role: user.role,\n                    token: generateToken(user._id)\n                });\n            } else {\n                res.status(401).json({ message: 'Invalid email or password' });\n            }\n        } catch (error) {\n            res.status(500).json({ message: error.message });\n        }\n    };\n\n    const getUserProfile = async (req, res) => {\n        // req.user is set by the protect middleware\n        res.json({\n            _id: req.user._id,\n            username: req.user.username,\n            email: req.user.email,\n            role: req.user.role\n        });\n    };\n\n    module.exports = { registerUser, loginUser, getUserProfile };\n    ```\n\n    ```javascript\n    // routes/userRoutes.js\n    const express = require('express');\n    const { registerUser, loginUser, getUserProfile } = require('../controllers/userController');\n    const { protect } = require('../middleware/authMiddleware');\n    const router = express.Router();\n\n    router.post('/register', registerUser);\n    router.post('/login', loginUser);\n    router.get('/profile', protect, getUserProfile); // Protected route\n\n    module.exports = router;\n    ```\n2.  **Product Routes (`routes/productRoutes.js`) and Controller (`controllers/productController.js`):**\n    * **Get All Products:** `GET /api/products`\n    * **Get Product by ID:** `GET /api/products/:id`\n    * **Create Product:** `POST /api/products` (Admin only)\n    * **Update Product:** `PUT /api/products/:id` (Admin only)\n    * **Delete Product:** `DELETE /api/products/:id` (Admin only)\n\n    *(Controller code for products, and orders would follow similar patterns. Below is an example for GET all products and POST create product.)*\n\n    ```javascript\n    // controllers/productController.js\n    const Product = require('../models/Product');\n\n    const getProducts = async (req, res) => {\n        try {\n            const products = await Product.find({});\n            res.json(products);\n        } catch (error) {\n            res.status(500).json({ message: error.message });\n        }\n    };\n\n    const createProduct = async (req, res) => {\n        const { name, description, price, stock, imageUrl } = req.body;\n        try {\n            const product = new Product({ name, description, price, stock, imageUrl });\n            const createdProduct = await product.save();\n            res.status(201).json(createdProduct);\n        } catch (error) {\n            res.status(400).json({ message: error.message });\n        }\n    };\n\n    // ... other controller functions for updateProduct, deleteProduct, getProductById\n\n    module.exports = { getProducts, createProduct /*, ... */ };\n    ```\n\n    ```javascript\n    // routes/productRoutes.js\n    const express = require('express');\n    const { getProducts, createProduct } = require('../controllers/productController');\n    const { protect, authorizeRoles } = require('../middleware/authMiddleware');\n    const router = express.Router();\n\n    router.get('/', getProducts);\n    router.post('/', protect, authorizeRoles('admin'), createProduct); // Admin-only route\n\n    module.exports = router;\n    ```\n3.  **Order Routes (`routes/orderRoutes.js`) and Controller (`controllers/orderController.js`):**\n    * **Create Order:** `POST /api/orders` (Protected)\n    * **Get User's Orders:** `GET /api/orders/myorders` (Protected)\n    * **Get All Orders:** `GET /api/orders` (Admin only)\n\n    *(You would implement the corresponding controller and routes similar to the User and Product examples, ensuring proper protection and authorization for specific roles.)*\n\n#### 4.5 Integrating Routes into `app.js`\n\nAdd your routes to the main Express application.\n\n```javascript\n// app.js (continued)\n// ... existing code ...\n\n// Import routes\nconst userRoutes = require('./routes/userRoutes');\nconst productRoutes = require('./routes/productRoutes');\nconst orderRoutes = require('./routes/orderRoutes');\n\n// Use routes\napp.use('/api/users', userRoutes);\napp.use('/api/products', productRoutes);\napp.use('/api/orders', orderRoutes);\n\n// ... existing server start ...\n```\n\n#### 4.6 Error Handling\n\nImplement basic error handling middleware to provide meaningful responses for unhandled errors.\n\n```javascript\n// app.js (continued)\n// ... existing routes ...\n\n// Custom error handler (add this at the end, after all routes)\napp.use((err, req, res, next) => {\n    console.error(err.stack);\n    res.status(err.statusCode || 500).json({\n        message: err.message || 'Server Error',\n        stack: process.env.NODE_ENV === 'production' ? null : err.stack, // Don't send stack in production\n    });\n});\n```\nFor a more robust solution, you might create a dedicated error handling middleware file.\n\n#### 4.7 Deployment Considerations\n\nOnce your basic backend is functional locally, you'll want to deploy it.\n\n1.  **Cloud Database:** Ensure your `MONGO_URI` points to a cloud-hosted MongoDB instance (e.g., MongoDB Atlas), not a local one, for accessibility from your deployed server.\n2.  **Environment Variables:** Configure environment variables on your chosen PaaS (Heroku, Render) to match those in your `.env` file (e.g., `MONGO_URI`, `JWT_SECRET`).\n3.  **Deployment Process:** Follow the deployment instructions specific to your chosen platform. Typically, this involves connecting your Git repository and configuring build and start commands.\n    * For Node.js on Heroku/Render, ensure your `package.json` has a `start` script:\n        ```json\n        \"scripts\": {\n            \"start\": \"node app.js\",\n            \"dev\": \"nodemon app.js\" // If you use nodemon for local development\n        },\n        ```\n    * Commit your code to a Git repository (e.g., GitHub). Make sure to add `.env` to your `.gitignore` file to prevent sensitive data from being pushed.\n\nBy following these steps, you will have built a basic, but functional, e-commerce backend capable of supporting a mobile application, demonstrating a comprehensive understanding of mobile backend development principles.\n\n---\n\n**Project Submission Note:**\n\nUpon completing this case study, you are encouraged to deploy your backend to a cloud platform. You can then submit a link to your deployed API endpoint (e.g., `https://your-ecommerce-backend.herokuapp.com/api/products`) or a link to your public GitHub repository containing the complete code for review.",
                    video_url: null,
                    video_url_embed: null,
                    is_active: true,
                    is_study_case: true,
                    created_at: "2025-08-21T01:31:54.308Z",
                    updated_at: "2025-08-21T01:32:23.454Z",
                    progress: [
                        {
                            is_done: false
                        }
                    ]
                }
            ]
        }
    }
}